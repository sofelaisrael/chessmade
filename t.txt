import React, { useState, useEffect, useRef } from "react";
import { Chessboard } from "react-chessboard";
import { Chess } from "chess.js";

import {
  AiOutlineClose,
  AiFillStepForward,
  AiFillStepBackward,
  AiFillFastBackward,
  AiFillFastForward,
} from "react-icons/ai";
import { RxExit } from "react-icons/rx";
import { FaChessKing, FaClock, FaCrown, FaFlag } from "react-icons/fa6";

const ChessBoard = ({ pgn, whiteresult, blackresult, username, game }) => {
  const [chess] = useState(new Chess());
  const [currentMoveIndex, setCurrentMoveIndex] = useState(0);
  const [moves, setMoves] = useState([]);
  const [gameInfo, setGameInfo] = useState({});
  const [playerColor, setPlayerColor] = useState("white");
  const [opponentInfo, setOpponentInfo] = useState({ name: "", rating: "" });
  const [userInfo, setUserInfo] = useState({ name: "", rating: "" });
  const chessboardRef = useRef(null);
  const [showTermination, setShowTermination] = useState(false);
  const popupRef = useRef(null);

  const [moveTreeRoot, setMoveTreeRoot] = useState(null);
  const [moveTreeLastNode, setMoveTreeLastNode] = useState(null);
  const [currentNode, setCurrentNode] = useState(null);

  const scrollToTop = () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const buildMoveTree = (chessInstance) => {
    const root = {
      move: null,
      fen: chessInstance.fen(),
      children: [],
      parent: null,
    };

    let current = root;
    const moves = chessInstance.history();

    chessInstance.reset();
    for (let move of moves) {
      const temp = new Chess(chessInstance.fen());
      const result = temp.move(move);
      const newNode = {
        move: result.san,
        fen: temp.fen(),
        children: [],
        parent: current,
      };
      current.children.push(newNode);
      current = newNode;
      chessInstance.move(move);
    }

    return root;
  };

  const renderMoveWithBranches = (moveNode) => {
    if (!moveNode || !moveNode.children) return moveNode.move;

    let moveText = moveNode.move;
    const branches = moveNode.children.map((child) => {
      return `(${renderMoveWithBranches(child)})`;
    });

    if (branches.length > 0) {
      moveText += ` ${branches.join(" ")}`;
    }

    return moveText;
  };

  const getCurrentLine = (node) => {
    const line = [];
    let currentNode = node;
  
    // Traverse the move tree to collect the move history from the root to the current node
    while (currentNode && currentNode.parent) {
      line.unshift(currentNode); // Add the current move to the front of the line
      currentNode = currentNode.parent;
    }
  
    return line;
  };

  const renderMoveList = () => {
    const moveList = [];

    let node = moveTreeRoot;
    const line = getCurrentLine(node);

    line.forEach((moveNode, index) => {
      const moveText = renderMoveWithBranches(moveNode);
      moveList.push(
        <span
          key={index}
          className={`px-2 py-1 rounded cursor-pointer transition-colors ${
            index < currentMoveIndex
              ? "bg-[#0f0f0f] hover:bg-[#00663d]"
              : "bg-[#1e1e1e] hover:bg-[#00aa55]"
          }`}
          onClick={() => {
            chess.reset();
            moves.slice(0, index + 1).forEach((m) => chess.move(m));
            setCurrentMoveIndex(index + 1);
          }}
        >
          {moveText}
        </span>
      );
    });

    return moveList;
  };

  const getLastNode = (node) => {
    let current = node;
    while (current.children.length > 0) {
      current = current.children[0];
    }
    return current;
  };

  useEffect(() => {
    if (pgn && typeof pgn === "string" && pgn.trim() !== "") {
      try {
        chess.loadPgn(pgn.trim()); // Make sure pgn is a trimmed string
        const history = chess.history();
        setMoves(history);
        setCurrentMoveIndex(history.length);

        const root = buildMoveTree(chess);
        const last = getLastNode(root);

        setMoveTreeRoot(root);
        setMoveTreeLastNode(last);
        setCurrentNode(last);

        const headers = chess.header();
        setGameInfo(headers);
        if (headers.White.toLocaleLowerCase() === username) {
          setPlayerColor("white");
          setUserInfo({ name: headers.White, rating: headers.WhiteElo });
          setOpponentInfo({ name: headers.Black, rating: headers.BlackElo });
        } else if (headers.Black.toLocaleLowerCase() === username) {
          setPlayerColor("black");
          setUserInfo({ name: headers.Black, rating: headers.BlackElo });
          setOpponentInfo({ name: headers.White, rating: headers.WhiteElo });
        }

        chess.reset();
        history.forEach((move) => chess.move(move));

        setShowTermination(true);
        scrollToTop();
      } catch (error) {
        console.error("Failed to load PGN:", error);
      }
    } else {
      chess.reset();
      setMoves([]);
      setCurrentMoveIndex(0);
      setGameInfo({});
    }
  }, [pgn, chess]);

  useEffect(() => {
    function handleKeyDown(e) {
      if (!moves.length) return;

      if (e.key === "ArrowLeft") {
        navigateMove(-1);
      } else if (e.key === "ArrowRight") {
        navigateMove(1);
      }
    }

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [chess, moves]);

  const navigateMove = (delta) => {
    setCurrentMoveIndex((prev) => {
      const newIndex = Math.max(0, Math.min(moves.length, prev + delta));
      chess.reset();
      moves.slice(0, newIndex).forEach((move) => chess.move(move));
      setShowTermination(false);
      return newIndex;
    });
  };

  const navigateToStart = () => {
    chess.reset();
    setCurrentMoveIndex(0);
    setShowTermination(false);
  };

  const navigateToEnd = () => {
    chess.reset();
    moves.forEach((move) => chess.move(move));
    setCurrentMoveIndex(moves.length);
    setShowTermination(false);
  };

  const closePopup = () => {
    setShowTermination(false);
  };

  useEffect(() => {
    const handleOutsideClick = (event) => {
      if (popupRef.current && !popupRef.current.contains(event.target)) {
        setShowTermination(false);
      }
    };

    document.addEventListener("mousedown", handleOutsideClick);
    return () => {
      document.removeEventListener("mousedown", handleOutsideClick);
    };
  }, []);

  const getGameStatusIcon = (result) => {
    switch (result) {
      case "win":
        return <FaCrown className="text-white w-3 h-3" title="Win" />;
      case "checkmated":
        return (
          <FaChessKing
            className="text-white w-3 h-3 transform -rotate-90"
            title="Checkmate"
          />
        );
      case "abandoned":
        return <RxExit className="text-white w-3 h-3" title="Left the Match" />;
      case "timeout":
        return <FaClock className="text-white w-3 h-3" title="Timeout" />;
      case "stalemate":
        return <div className="text-white w-3 h-3 ">1/2</div>;
      case "timevsinsufficient":
        return <div className="text-white w-3 h-3 ">1/2</div>;
      case "timeoutvsinsufficient":
        return <div className="text-white w-3 h-3 ">1/2</div>;
      case "repetition":
        return <div className="text-white w-3 h-3 ">1/2</div>;
      case "agreed":
        return <div className="text-white w-3 h-3 ">1/2</div>;
      case "50move":
        return <div className="text-white w-3 h-3 ">1/2</div>;
      case "insufficient":
        return <div className="text-white w-3 h-3 ">1/2</div>;
      case "resigned":
        return <FaFlag className="text-white w-3 h-3" title="Resigned" />;
      default:
        return null;
    }
  };

  const setCurrentMoveIndexFromNode = (node) => {
  let count = 0;
  let current = node;

  // Walk up the tree and count moves
  while (current && current.parent) {
    count++;
    current = current.parent;
  }

  setCurrentMoveIndex(count);
  console.log(currentMoveIndex)
};


  const handlePieceDrop = (sourceSquare, targetSquare) => {
    if (!currentNode || !moveTreeRoot) return false;

    setMoveTreeRoot({ ...moveTreeRoot }); // force re-render

    const tempChess = new Chess(currentNode.fen);
    const move = chess.move({
      from: sourceSquare,
      to: targetSquare,
      promotion: "q",
    });

    if (move === null) return false;

    // Check if this move already exists as a child (avoid duplicate branches)
    const existing = currentNode.children.find(
      (child) => child.move === move.san
    );

    if (existing) {
      setCurrentNode(existing);
      chess.load(existing.fen);
      setCurrentMoveIndexFromNode(existing);
      return true;
    }

    // Create a new branch node
    const newNode = {
      move: move.san,
      fen: tempChess.fen(),
      children: [],
      parent: currentNode,
    };

    currentNode.children.push(newNode);
    setCurrentNode(newNode);
    setMoveTreeRoot({ ...moveTreeRoot }); // trigger re-render

    chess.load(tempChess.fen);
    setCurrentMoveIndexFromNode(newNode);

    return true;
  };

  return (
    <div className="space-y-4">
      <div className="text p">
        <div className="font-semibold flex items-center gap-2">
          {opponentInfo.name && (
            <div className="sm text-white">
              {opponentInfo.name} ({opponentInfo.rating})
            </div>
          )}
          {currentMoveIndex === moves.length && currentMoveIndex !== 0 && (
            <div
              style={{
                background: `${
                  (playerColor === "black" && whiteresult === "win") ||
                  (playerColor === "white" && blackresult === "win")
                    ? "green"
                    : (playerColor === "white" && whiteresult === "win") ||
                      (playerColor === "black" && blackresult === "win")
                    ? "red"
                    : "gray"
                }`,
              }}
              className="size-6 p-1 rounded-full flex justify-center items-center icon-animation relative text-[9px]"
            >
              {playerColor === "white" ? (
                <div className="ch font-bold">
                  {getGameStatusIcon(blackresult)}
                </div>
              ) : (
                <div className="ch font-bold">
                  {getGameStatusIcon(whiteresult)}
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      <div
        className="aspect-square max-w-md mx-auto relative"
        ref={chessboardRef}
      >
        <Chessboard
          customDarkSquareStyle={{ backgroundColor: "#171D27" }}
          customLightSquareStyle={{ backgroundColor: "#373D49" }}
          customBoardStyle={{ borderRadius: "5px" }}
          boardOrientation={playerColor}
          position={chess.fen()}
          onPieceDrop={handlePieceDrop}
        />
        {showTermination && (
          <div
            ref={popupRef}
            className="bg-whie p-6 rounded-lg backdrop-blur-2xl shadow-lg w-fit absolute top-[50%] left-[50%] -translate-x-1/2 -translate-y-1/2 text-white font-bold leading-[15px]"
          >
            <p>{gameInfo.Termination}</p>

            <button
              onClick={closePopup}
              className="absolute top-2 right-2 text-white hover:text-gray-700"
            >
              <AiOutlineClose className="w-6 h-6" />
            </button>
          </div>
        )}
      </div>

      <div className="text- p">
        <div className="font-semibold flex items-center gap-2 text-white">
          {userInfo.name && (
            <div className="sm">
              {userInfo.name} ({userInfo.rating})
            </div>
          )}
          {currentMoveIndex === moves.length && currentMoveIndex !== 0 && (
            <div
              style={{
                background: `${
                  (playerColor === "black" && whiteresult === "win") ||
                  (playerColor === "white" && blackresult === "win")
                    ? "red"
                    : (playerColor === "white" && whiteresult === "win") ||
                      (playerColor === "black" && blackresult === "win")
                    ? "green"
                    : "gray"
                }`,
              }}
              className="size-6 rounded-full flex justify-center items-center icon-animation relative text-[9px]"
            >
              {playerColor === "white" ? (
                <div className="ch font-bold">
                  {getGameStatusIcon(whiteresult)}
                </div>
              ) : (
                <div className="ch font-bold">
                  {getGameStatusIcon(blackresult)}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
      {/* {whiteresult} - {blackresult} */}
      <div className="flex items-center justify-center space-x-4 text-white text-[20px]">
        <button
          onClick={navigateToStart}
          className="p-2 rounded-lg hover:bg-[#1e1e1e] transition-colors disabled:opacity-50"
          disabled={currentMoveIndex === 0}
          title="Go to start"
        >
          <AiFillFastBackward />
        </button>
        <button
          onClick={() => navigateMove(-1)}
          className="p-2 rounded-lg hover:bg-[#1e1e1e] transition-colors disabled:opacity-50"
          disabled={currentMoveIndex === 0}
          title="Previous move"
        >
          <AiFillStepBackward />
        </button>
        <span className="font-mono px-4 py-2 bg-[#1e1e1e] rounded-lg">
          {currentMoveIndex} / {moves.length}
        </span>
        <button
          onClick={() => navigateMove(1)}
          className="p-2 rounded-lg hover:bg-[#1e1e1e] transition-colors disabled:opacity-50"
          disabled={currentMoveIndex === moves.length}
          title="Next move"
        >
          <AiFillStepForward />
        </button>
        <button
          onClick={navigateToEnd}
          className="p-2 rounded-lg hover:bg-[#1e1e1e] transition-colors disabled:opacity-50"
          disabled={currentMoveIndex === moves.length}
          title="Go to end"
        >
          <AiFillFastForward />
        </button>
      </div>
      {pgn && (
        <div className="space-y-4">
          <div className="bg-[#1e1e1e] text-white p-4 rounded-lg">
            <h4 className="font-semibold mb-2">Moves</h4>
            <div className="flex flex-wrap gap-2">
              {moves.map((move, index) => (
                <span
                  key={index}
                  className={`px-2 py-1 rounded cursor-pointer transition-colors ${
                    index < currentMoveIndex
                      ? "bg-[#0f0f0f] hover:bg-[#00663d]"
                      : "bg-[#1e1e1e] hover:bg-[#00aa55]"
                  }`}
                  onClick={() => {
                    chess.reset();
                    moves.slice(0, index + 1).forEach((m) => chess.move(m));
                    setCurrentMoveIndex(index + 1);
                  }}
                >
                  {index % 2 === 0 ? `${Math.floor(index / 2) + 1}.` : ""}{" "}
                  {move}
                </span>
              ))}

              <div className="space-y-4">
                <div className="bg-[#1e1e1e] text-white p-4 rounded-lg">
                  <h4 className="font-semibold mb-2">Moves</h4>
                  <div className="flex flex-wrap gap-2">{renderMoveList()}</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
export default ChessBoard;




















const renderMoves = (node, moveNumber = 1, isWhiteMove = true, inVariation = false) => {
  if (!node || node.children.length === 0) return null;

  const firstChild = node.children[0];
  const variations = node.children.slice(1); // All non-mainline children

  // Show move number only on white moves
  const showMoveNumber = isWhiteMove ? `${moveNumber}.` : "";

  const moveButton = firstChild && (
    <button
      key={`main-${firstChild.move}`}
      className={`px-1 rounded ${
        currentNode === firstChild ? "bg-blue-500 text-white" : "bg-gray-200"
      } ${inVariation ? "italic text-sm text-gray-500" : ""}`}
      onClick={() => goToNode(firstChild)}
    >
      {showMoveNumber} {firstChild.move}
    </button>
  );

  const variationElements = variations.map((child, index) => (
    <span key={`variation-${index}`} className="flex flex-wrap items-center space-x-1 italic text-sm text-gray-500">
      <span>(</span>
      <span className="flex flex-wrap items-center space-x-1">
        {renderMoves(child, moveNumber, isWhiteMove, true)}
      </span>
      <span>)</span>
    </span>
  ));

  return (
    <span className="flex flex-wrap items-center gap-1 text-sm">
      {moveButton}
      {variationElements}
      {renderMoves(firstChild, isWhiteMove ? moveNumber : moveNumber + 1, !isWhiteMove, inVariation)}
    </span>
  );
};






{showDropdown && opponentList.length > 0 && searchQuery && (
                    <ul className="rounded shadow-md max-h-40 overflow-y-auto abste bottom-0">
                      {opponentList
                        .filter((item) =>
                          item.value
                            .toLowerCase()
                            .includes(searchQuery.toLowerCase())
                        )
                        .map((item, index) => (
                          <li
                            key={index}
                            className="px-4 py-2 hover:bg-[#171D27] text-white cursor-pointer flex justify-between go  mr-2 rounded"
                            onClick={() => handleDropdownSelect(item)}
                          >
                            <span>
                              <span className="text-sm gap-2 flex items-center ">
                                {item.type === "opponent" ? (
                                  <CgUser />
                                ) : (
                                  <FaChessPawn />
                                )}
                                {item.value}
                              </span>
                            </span>
                            <span className="text-sm font-bold">
                              {item.count}
                            </span>
                          </li>
                        ))}
                    </ul>
                  )}










 const renderFullMoveTree = (node) => {
    if (!node || node.children.length === 0) return null;
  
    const renderLine = (lineNode) => {
      const moves = [];
  
      let current = lineNode;
      while (current && current.children.length > 0) {
        const firstChild = current.children[0];
  
        // Main move or branch move
        moves.push(
          <button
            key={firstChild.fen}
            onClick={() => {
              setCurrentNode(firstChild);
              chess.load(firstChild.fen);
              setCurrentMoveIndexFromNode(firstChild);
            }}
            className={`px-1 rounded ${
              firstChild === currentNode ? "bg-yellow-500 text-black" : "bg-gray-700"
            }`}
          >
            {firstChild.move}
          </button>
        );
  
        // Render any branches from this move (besides firstChild)
        const branches = firstChild.children.slice(1);
        if (branches.length > 0) {
          moves.push(
            <span key={`branches-${firstChild.fen}`} className="flex gap-1 text-sm items-center">
              (
              {branches.map((branch) => (
                <span key={branch.fen} className="flex gap-1">
                  {renderLine(branch)}
                </span>
              ))}
              )
            </span>
          );
        }
  
        current = firstChild;
      }
  
      return moves;
    };
  
    return <div className="flex flex-wrap gap-2 text-white">{renderLine(node)}</div>;
  };